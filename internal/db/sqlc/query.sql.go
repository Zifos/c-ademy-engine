// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addToAllowlist = `-- name: AddToAllowlist :exec
INSERT INTO allowlist (username, is_allowed)
VALUES (?, ?)
ON CONFLICT(username) DO UPDATE SET is_allowed = excluded.is_allowed
`

type AddToAllowlistParams struct {
	Username  string
	IsAllowed bool
}

func (q *Queries) AddToAllowlist(ctx context.Context, arg AddToAllowlistParams) error {
	_, err := q.db.ExecContext(ctx, addToAllowlist, arg.Username, arg.IsAllowed)
	return err
}

const checkUsernameAllowed = `-- name: CheckUsernameAllowed :one
SELECT EXISTS(SELECT 1 FROM allowlist WHERE username = ? AND is_allowed = 1) AS username_allowed
`

// Allowlist-related queries
func (q *Queries) CheckUsernameAllowed(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkUsernameAllowed, username)
	var username_allowed int64
	err := row.Scan(&username_allowed)
	return username_allowed, err
}

const checkUsernameExists = `-- name: CheckUsernameExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE username = ?) AS username_exists
`

func (q *Queries) CheckUsernameExists(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkUsernameExists, username)
	var username_exists int64
	err := row.Scan(&username_exists)
	return username_exists, err
}

const createExecution = `-- name: CreateExecution :execresult
INSERT INTO executions (
    user_id, language, code, input, expected_output, webhook_url
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateExecutionParams struct {
	UserID         int64
	Language       string
	Code           string
	Input          sql.NullString
	ExpectedOutput sql.NullString
	WebhookUrl     sql.NullString
}

// Execution-related queries
func (q *Queries) CreateExecution(ctx context.Context, arg CreateExecutionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createExecution,
		arg.UserID,
		arg.Language,
		arg.Code,
		arg.Input,
		arg.ExpectedOutput,
		arg.WebhookUrl,
	)
}

const createToken = `-- name: CreateToken :execresult
INSERT INTO api_tokens (user_id, token, expires_at)
VALUES (?, ?, ?)
`

type CreateTokenParams struct {
	UserID    int64
	Token     string
	ExpiresAt sql.NullTime
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createToken, arg.UserID, arg.Token, arg.ExpiresAt)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (username, password_hash)
VALUES (?, ?)
`

type CreateUserParams struct {
	Username     string
	PasswordHash string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser, arg.Username, arg.PasswordHash)
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM api_tokens
WHERE token = ?
`

func (q *Queries) DeleteToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteToken, token)
	return err
}

const getExecutionByID = `-- name: GetExecutionByID :one
SELECT id, user_id, language, code, input, expected_output, stdout, stderr, webhook_url, created_at, updated_at
FROM executions
WHERE id = ?
`

type GetExecutionByIDRow struct {
	ID             int64
	UserID         int64
	Language       string
	Code           string
	Input          sql.NullString
	ExpectedOutput sql.NullString
	Stdout         sql.NullString
	Stderr         sql.NullString
	WebhookUrl     sql.NullString
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
}

func (q *Queries) GetExecutionByID(ctx context.Context, id int64) (GetExecutionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getExecutionByID, id)
	var i GetExecutionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Language,
		&i.Code,
		&i.Input,
		&i.ExpectedOutput,
		&i.Stdout,
		&i.Stderr,
		&i.WebhookUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getToken = `-- name: GetToken :one
SELECT id, user_id, token, expires_at, created_at
FROM api_tokens
WHERE token = ?
`

// Token-related queries
func (q *Queries) GetToken(ctx context.Context, token string) (ApiToken, error) {
	row := q.db.QueryRowContext(ctx, getToken, token)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, password_hash, created_at, updated_at
FROM users
WHERE id = ?
`

// User-related queries
func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, created_at, updated_at
FROM users
WHERE username = ?
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUserExecutions = `-- name: ListUserExecutions :many
SELECT id, language, code, input, expected_output, stdout, stderr, webhook_url, created_at, updated_at
FROM executions
WHERE user_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListUserExecutionsParams struct {
	UserID int64
	Limit  int64
}

type ListUserExecutionsRow struct {
	ID             int64
	Language       string
	Code           string
	Input          sql.NullString
	ExpectedOutput sql.NullString
	Stdout         sql.NullString
	Stderr         sql.NullString
	WebhookUrl     sql.NullString
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
}

func (q *Queries) ListUserExecutions(ctx context.Context, arg ListUserExecutionsParams) ([]ListUserExecutionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserExecutions, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserExecutionsRow
	for rows.Next() {
		var i ListUserExecutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Language,
			&i.Code,
			&i.Input,
			&i.ExpectedOutput,
			&i.Stdout,
			&i.Stderr,
			&i.WebhookUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFromAllowlist = `-- name: RemoveFromAllowlist :exec
DELETE FROM allowlist
WHERE username = ?
`

func (q *Queries) RemoveFromAllowlist(ctx context.Context, username string) error {
	_, err := q.db.ExecContext(ctx, removeFromAllowlist, username)
	return err
}

const updateAllowlistStatus = `-- name: UpdateAllowlistStatus :exec
UPDATE allowlist
SET is_allowed = ?
WHERE username = ?
`

type UpdateAllowlistStatusParams struct {
	IsAllowed bool
	Username  string
}

func (q *Queries) UpdateAllowlistStatus(ctx context.Context, arg UpdateAllowlistStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateAllowlistStatus, arg.IsAllowed, arg.Username)
	return err
}

const updateExecution = `-- name: UpdateExecution :exec
UPDATE executions
SET 
    stdout = ?,
    stderr = ?,
    exit_code = ?
WHERE id = ?
`

type UpdateExecutionParams struct {
	Stdout   sql.NullString
	Stderr   sql.NullString
	ExitCode sql.NullInt64
	ID       int64
}

func (q *Queries) UpdateExecution(ctx context.Context, arg UpdateExecutionParams) error {
	_, err := q.db.ExecContext(ctx, updateExecution,
		arg.Stdout,
		arg.Stderr,
		arg.ExitCode,
		arg.ID,
	)
	return err
}

const updateExecutionOutput = `-- name: UpdateExecutionOutput :exec
UPDATE executions
SET stdout = ?
WHERE id = ?
`

type UpdateExecutionOutputParams struct {
	Stdout sql.NullString
	ID     int64
}

func (q *Queries) UpdateExecutionOutput(ctx context.Context, arg UpdateExecutionOutputParams) error {
	_, err := q.db.ExecContext(ctx, updateExecutionOutput, arg.Stdout, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = ?
WHERE id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string
	ID           int64
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const updateUsername = `-- name: UpdateUsername :exec
UPDATE users
SET username = ?
WHERE id = ?
`

type UpdateUsernameParams struct {
	Username string
	ID       int64
}

func (q *Queries) UpdateUsername(ctx context.Context, arg UpdateUsernameParams) error {
	_, err := q.db.ExecContext(ctx, updateUsername, arg.Username, arg.ID)
	return err
}
